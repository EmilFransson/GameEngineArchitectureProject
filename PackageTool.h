#pragma once
#include "OBJ_Loader.h"
class PackageTool
{
private:
	struct PackagedTexture
	{
		uint32_t width, height;
		uint32_t rowPitch;
		std::vector<BYTE> dataVec;
	};

public:
	struct PackageHeader
	{
		char id[3]; // PCK or PKG or whatever, not strictly necessary but feels official
		uint8_t assetCount;
		uint32_t size;
	};

	struct ChunkHeader
	{
		char type[4];				// Ex: TEX, MESH, AUD ...
		uint32_t chunkSize;			// Chunk header not included
		GUID guid;					// Generated by hashing the compressed data.
		uint64_t readableSize;
		// Here follows a non-zero-terminated string that is the humanreadble name. Read as you deem fit
	};

	struct TextureHeader
	{
		char textureType[4]; // COL, NORM, SPEC ...
		uint32_t dataSize;
		uint32_t width, height;
		uint32_t rowPitch;
	};

	struct MeshHeader
	{
		char meshName[64];
		char materialName[64];		//The material the mesh uses.
		uint64_t verticesDataSize;	//The size of the vertexdata part of the data.
		uint64_t indicesDataSize;	//The size of the indexdata part of the data.
	};
	
	struct MaterialHeader
	{
		char materialName[64];
		uint32_t dataSize;
	};

	struct SMaterial
	{
		char fileName[30];
		// Material Name
		char name[30];
		// Ambient Color
		objl::Vector3 Ka;
		// Diffuse Color
		objl::Vector3 Kd;
		// Specular Color
		objl::Vector3 Ks;
		// Specular Exponent
		float Ns;
		// Optical Density
		float Ni;
		// Dissolve
		float d;
		// Illumination
		int illum;
		// Ambient Texture Map
		char map_Ka[30];
		// Diffuse Texture Map
		char map_Kd[30];
		// Specular Texture Map
		char map_Ks[30];
		// Specular Hightlight Map
		char map_Ns[30];
		// Alpha Texture Map
		char map_d[30];
		// Bump Map
		char map_bump[30];
	};
private:
public:
	PackageTool() = default;
	~PackageTool() = default;

	static std::string Package(const char* dirPath);
private:
	static PackagedTexture PackageTexture(const std::string& texPath);
	static void PadTexture(PackagedTexture& tex, const BYTE* imgData, int channels);
	static void CompressTexture(PackagedTexture& tex);
};

